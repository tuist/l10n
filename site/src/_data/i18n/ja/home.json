{
  "meta": {
    "title": "l10n · ソフトウェアをリリースするように翻訳する",
    "description": "翻訳をリポジトリ内で管理し、ツールチェーンで検証し、LLMによるドラフト生成で素早くリリース。"
  },
  "hero": {
    "badge": "オープンソースCLIツール",
    "title": "コードベースのためのエージェント型ローカライゼーション",
    "lead": "l10nはLLMでコンテンツを翻訳し、すべてをリポジトリ内に保持し、出力をローカルで検証します。外部プラットフォームとのやり取りなしに、チームがレビューできるドラフトを生成します。",
    "cta_primary": "はじめる",
    "cta_secondary": "仕組み"
  },
  "origin": {
    "title": "Tuistがこれを作った理由",
    "intro": {
      "prefix": "",
      "crowdin": "Crowdin",
      "middle": "と",
      "weblate": "Weblate",
      "suffix": "を試しました。コンテンツのエクスポートとインポートの間接的なワークフローがスピードを落とし、独自のバリデーションをループに組み込むことができませんでした。コードと同じワークフローが欲しかったのです：変更、テスト、レビュー、リリース。"
    },
    "note": "今では翻訳はその場で生成され、ツールチェーンでチェックされ、人間のレビューは本当に必要な時だけ行われます。"
  },
  "how": {
    "title": "仕組み",
    "steps": [
      {
        "number": "01",
        "title": "エージェントにコンテキストを与える",
        "text": "コンテンツと一緒にL10N.mdコンテキストファイルを配置します。l10nは依存関係を追跡するので、コンテキストやコンテンツが変更されると、影響を受ける翻訳だけが再生成されます。"
      },
      {
        "number": "02",
        "title": "モデルを選択する",
        "text": "エージェントセッションを調整するモデルと、正確に翻訳するモデルをそれぞれ選びます。OpenAI互換エンドポイント、Vertex AI、または自前でホストしたモデルを使用できます。"
      },
      {
        "number": "03",
        "title": "エージェントが自身の作業を検証する",
        "text": "エージェントは組み込みの構文チェックと、あなたが定義したカスタムコマンドにアクセスできます。各翻訳後にバリデーションを実行し、エラー時にはリトライするので、レビュー前に正しい出力が得られます。"
      }
    ]
  },
  "config": {
    "title": "設定はリポジトリ内に置く",
    "l10n": {
      "title": "L10N.md",
      "text": "TOMLフロントマターで翻訳ソース、ターゲット、出力パターンを定義します。"
    },
    "cli": {
      "title": "CLIコマンド",
      "text": "翻訳、検証、更新が必要なものの追跡を行います。",
      "items": [
        {
          "cmd": "l10n init",
          "desc": "対話形式でプロジェクトをセットアップ"
        },
        {
          "cmd": "l10n translate",
          "desc": "翻訳を生成"
        },
        {
          "cmd": "l10n status",
          "desc": "不足または古くなった出力をレポート"
        },
        {
          "cmd": "l10n check",
          "desc": "出力の構文を検証"
        },
        {
          "cmd": "l10n clean",
          "desc": "古くなった翻訳出力を削除"
        }
      ],
      "note_prefix": "",
      "note_suffix": "ですべてを再翻訳できます。"
    }
  },
  "features": {
    "title": "実際のワークフローのために設計",
    "items": [
      {
        "title": "コンテキスト対応ハッシュ",
        "text": "ソースコンテンツまたは上位のL10N.mdコンテキストが変更されると、翻訳が更新されます。"
      },
      {
        "title": "バリデーションフック",
        "text": "JSON、YAML、PO構文チェックに加え、オプションで外部lintコマンドも実行可能。"
      },
      {
        "title": "エージェントパイプライン",
        "text": "コーディネーターと翻訳者のモデルを分離し、バリデーションエラー時にはリトライ。"
      },
      {
        "title": "人間のレビューに対応",
        "text": "ドラフトを素早く生成し、必要に応じてレビューし、すべてをGitで管理。"
      }
    ]
  },
  "faq": {
    "title": "FAQ",
    "items": [
      {
        "q": "従来の翻訳ツールと何が違うのですか？",
        "a": "従来のツールは翻訳メモリ、つまり類似度でマッチングされる過去の翻訳の静的データベースに依存しています。l10nはそれをLLMコンテキストをメモリとして置き換えます：エージェントが読み取り、学習し、チームが時間をかけて改善できるコンテキストファイルです。曖昧なマッチを検索する代わりに、エージェントはあなたのプロダクトのトーン、用語、規約を理解します。そして開発者がコンパイルやlintでコード変更を検証するように、エージェントはあなたの環境にある同じツールを使って翻訳を検証します。CIでもローカルでも実行でき、エージェントはあなたのlinter、コンパイラ、バリデーターを使って自身の出力を修正します。"
      },
      {
        "q": "自分でモデルを用意する必要がありますか？",
        "a": "はい。l10nはCLIツールであり、ホスティングサービスではありません。OpenAI互換エンドポイント、Vertex AI、または自前のモデルを指定します。コスト、データ、品質はあなたがコントロールします。"
      },
      {
        "q": "人間はどのように翻訳をレビューしますか？",
        "a": "現在、レビュアーはプルリクエストとdiffを通じて翻訳されたコンテンツを確認し、必要に応じてコンテキストファイルを更新して再翻訳を強制できます。将来的には、開発者がCodexのようなコーディングエージェントを使うのと同じように、l10nをローカルで実行することでループの一部になることを想定しています。"
      }
    ]
  },
  "updates": {
    "title": "更新情報"
  }
}
{
  "meta": {
    "title": "l10n · 像发布软件一样做本地化",
    "description": "本地化内容保留在代码仓库中，使用现有工具验证，借助 LLM 草稿加速交付。"
  },
  "hero": {
    "badge": "开源命令行工具",
    "title": "代码库的智能体本地化方案",
    "lead": "l10n 使用 LLM 翻译内容，所有文件保留在仓库中，本地验证输出结果，生成团队可直接审核的草稿——无需依赖外部平台的导入导出流程。",
    "cta_primary": "快速开始",
    "cta_secondary": "工作原理"
  },
  "origin": {
    "title": "为什么 Tuist 要开发这个工具",
    "intro": {
      "prefix": "我们尝试过 ",
      "crowdin": "Crowdin",
      "middle": " 和 ",
      "weblate": "Weblate",
      "suffix": "。内容导入导出的间接流程拖慢了我们的节奏，而且无法在流程中运行自定义验证。我们想要的是和写代码一样的工作流：修改、测试、审核、发布。"
    },
    "note": "现在，翻译直接在仓库中生成，由你的工具链检查，只在必要时才需要人工审核。"
  },
  "how": {
    "title": "工作原理",
    "steps": [
      {
        "number": "01",
        "title": "为智能体提供上下文",
        "text": "在内容文件旁添加 L10N.md 上下文文件。l10n 会追踪依赖关系，当上下文或内容变更时，仅重新生成受影响的翻译。"
      },
      {
        "number": "02",
        "title": "选择模型",
        "text": "指定一个模型协调智能体会话，另一个模型负责精准翻译。支持任何 OpenAI 兼容端点、Vertex AI 或自托管模型。"
      },
      {
        "number": "03",
        "title": "智能体自主验证输出",
        "text": "智能体可调用内置语法检查和你定义的自定义命令。每次翻译后自动运行验证，遇到错误自动重试，确保输出正确后再提交审核。"
      }
    ]
  },
  "tools": {
    "title": "工具",
    "intro": "智能体使用工具在每次翻译后自动验证。",
    "categories": [
      {
        "title": "语法验证器",
        "text": "解析输出，确保格式正确后再保存。",
        "items": [
          "JSON",
          "YAML",
          "PO",
          "Markdown frontmatter"
        ]
      },
      {
        "title": "保留检查",
        "text": "确保关键标记在翻译后完整保留。",
        "items": [
          "代码块",
          "行内代码",
          "URL",
          "占位符"
        ]
      },
      {
        "title": "自定义命令",
        "text": "通过 check_cmd 和 check_cmds 接入你自己的验证器。",
        "items": [
          "Linter",
          "编译器",
          "Schema 验证器"
        ]
      }
    ],
    "note": "工具验证失败会触发重试，直到输出有效。"
  },
  "config": {
    "title": "配置保存在仓库中",
    "l10n": {
      "title": "L10N.md",
      "text": "在 TOML frontmatter 中定义翻译源、目标语言和输出路径。"
    },
    "cli": {
      "title": "CLI 命令",
      "text": "翻译、验证、追踪待更新内容。",
      "items": [
        {
          "cmd": "l10n init",
          "desc": "交互式项目初始化"
        },
        {
          "cmd": "l10n translate",
          "desc": "生成翻译"
        },
        {
          "cmd": "l10n status",
          "desc": "报告缺失或过期的输出"
        },
        {
          "cmd": "l10n check",
          "desc": "验证输出语法"
        },
        {
          "cmd": "l10n clean",
          "desc": "清理过期的翻译输出"
        }
      ],
      "note_prefix": "使用",
      "note_suffix": "重新翻译所有内容。"
    }
  },
  "features": {
    "title": "为真实工作流设计",
    "items": [
      {
        "title": "上下文感知哈希",
        "text": "当源内容或上级 L10N.md 上下文变更时，翻译自动更新。"
      },
      {
        "title": "验证钩子",
        "text": "内置 JSON、YAML、PO 语法检查，支持可选的外部 lint 命令。"
      },
      {
        "title": "智能体流水线",
        "text": "协调器和翻译器使用独立模型，验证失败自动重试。"
      },
      {
        "title": "便于人工审核",
        "text": "快速生成草稿，按需审核，所有内容保留在 Git 中。"
      }
    ]
  },
  "refinement": {
    "title": "渐进式优化",
    "lead": "翻译不必一步到位。和代码一样，翻译通过迭代逐步完善。",
    "text": "LLM 生成的初稿结构正确，但可能在语气、细微差别或领域术语上有所欠缺。这是预期行为。每次审核周期——PR 评论、更新上下文文件、调整术语表——都会反馈到下一轮翻译中。质量通过多轮迭代收敛，而非一次成型。",
    "steps": [
      {
        "label": "草稿",
        "text": "LLM 根据上下文文件生成结构正确的初稿。"
      },
      {
        "label": "审核",
        "text": "团队通过 Pull Request 反馈问题，和代码审核一样。"
      },
      {
        "label": "优化",
        "text": "更新的上下文和术语修正会反馈到下一轮翻译，缩小差距。"
      },
      {
        "label": "收敛",
        "text": "每次迭代都更接近生产质量。系统逐渐学习你产品的表达风格。"
      }
    ],
    "prior_art": "这遵循的原则和制造业的 Kaizen（持续改进）、专业翻译中的译后编辑（PEMT）、工程中的逐次逼近法一致：从一个足够好的基线开始，在人工判断的参与下系统性地改进。"
  },
  "faq": {
    "title": "常见问题",
    "items": [
      {
        "q": "这和传统翻译工具有什么不同？",
        "a": "传统工具依赖翻译记忆库——按相似度匹配的历史翻译静态数据库。l10n 用 LLM 上下文替代翻译记忆：智能体读取、学习上下文文件，团队可以随时间迭代改进。智能体不是查找模糊匹配，而是理解你产品的语气、术语和规范。就像开发者通过编译或 lint 验证代码变更一样，智能体使用你环境中的同一套工具验证翻译。无论在 CI 还是本地运行，智能体都会用你的 linter、编译器和验证器来修正自己的输出。"
      },
      {
        "q": "需要自己提供模型吗？",
        "a": "需要。l10n 是命令行工具，不是托管服务。你可以指向任何 OpenAI 兼容端点、Vertex AI 或自托管模型。成本、数据和质量完全由你掌控。"
      },
      {
        "q": "人工如何审核翻译？",
        "a": "目前，审核人员通过 Pull Request 和 diff 检查翻译内容，可以更新上下文文件来触发重新翻译。未来，我们预期审核人员将在本地运行 l10n 参与流程，就像开发者使用 Codex 等编程智能体一样。"
      }
    ]
  },
  "updates": {
    "title": "更新动态"
  }
}
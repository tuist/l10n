---
title: "Localization was stuck in the past. We built l10n to move it forward."
summary: "Traditional localization tools add overhead, break CI, and lock you into vendor ecosystems. We replaced all of that with coding agents that translate where development happens."
date: 2026-02-03
layout: layouts/post.njk
---
둘 이상의 언어로 소프트웨어를 출시해 본 적이 있다면, 이 과정이 익숙할 것입니다. 로컬라이제이션 플랫폼을 선택하고, 저장소에 연결한 다음, 남은 시간은 동기화 관리에 쓰게 됩니다. 콘텐츠가 나가고, 번역이 돌아오고, 그 사이 어딘가에서 문제가 생깁니다.

저장소와의 끊임없는 콘텐츠 왕복, 이 오버헤드는 오늘날의 로컬라이제이션 도구를 사용하는 모든 팀이 지불하는 세금입니다. 금요일 오후 6시에 번역 PR이 사이트 빌드를 깨뜨린 이유를 디버깅하는 당사자가 되기 전까지는 사소해 보입니다.

## 인터넷 이전부터 이어져 온 설계

대부분의 로컬라이제이션 플랫폼은 현대 개발 워크플로우 이전의 개념을 기반으로 설계되었습니다. 번역 메모리. 퍼지 매칭. 데이터베이스에서 유사한 문자열을 제안하는 도구의 지원을 받으며 독점 에디터 안에서 작업하는 인간 번역가들.

번역이 수동적이고 오프라인 프로세스였던 시절에는 이러한 아이디어가 합리적이었습니다. 하지만 기업들은 번역 메모리를 락인 메커니즘으로 바꿔버렸습니다. 비용을 들여 쌓아온 과거 번역, 그 기관 지식이 그들의 플랫폼 안에 존재합니다. 다른 제공자로 이동하면 처음부터 다시 시작하거나, 제대로 작동하지 않는 내보내기에 비용을 지불해야 합니다.

결과는 인위적인 마찰 위에 세워진 산업입니다. 콘텐츠가 저장소를 떠나 블랙박스에 들어갔다가 다른 누군가의 일정에 맞춰 돌아옵니다.

## 아무도 말하지 않는 CI 문제

[Tuist](https://tuist.dev)에서 우리는 문서 사이트와 마케팅 사이트를 로컬라이즈합니다. 외부 로컬라이제이션 플랫폼을 사용했고, 그 도구들이 열어주는 풀 리퀘스트가 자동화된 검사에서 실패하는 경우를 자주 겪었습니다.

문제는 구조적입니다. 외부 로컬라이제이션 도구는 CI 파이프라인을 실행할 수 없습니다. 린터도, 빌드 단계도, 링크 체커도, 프론트매터 스키마도 모릅니다. 번역된 콘텐츠를 저장소에 푸시하고 잘 되기를 바랄 뿐입니다.

이건 정말 답답했습니다. 번역 배치를 받으면 PR이 CI에서 실패하고, 팀원 중 누군가는 하던 일을 멈추고 번역 도구가 만들어낸 포맷팅 문제, 깨진 구문, 잘못된 마크업을 수정해야 했습니다. 애초에 문제가 되지 말아야 할 것들을 해결하느라 실제 작업에서 에너지가 빠져나갔습니다.

## 모든 것을 바꾼 대화

l10n 아이디어는 로컬라이제이션 경험이 풍부한 [Maria Jose](https://github.com/mjsesalm)와 생각하고 대화하면서 나왔습니다. 그녀의 경험은 아이디어를 구체화하는 데 결정적이었습니다. 언어학적 측면과 도구의 불편함 모두를 깊이 이해하고 있었습니다.

함께 간단한 질문을 던졌습니다: **로컬라이제이션 에이전트가 개발자가 사용하는 것과 같은 도구를 사용한다면 어떨까?**

파일을 왕복으로 동기화하는 플랫폼이 아닙니다. 코드베이스와 단절된 웹 에디터도 아닙니다. 대신, 프로젝트, 환경, 검증 도구에 접근할 수 있는 코딩 에이전트입니다. 파일을 번역하고, 린터를 실행하고, 출력을 확인하고, 문제가 생기면 재시도할 수 있는 에이전트입니다. 풀 리퀘스트를 열기 전에 이 모든 것을 수행합니다.

아이디어는 로컬라이제이션을 개발이 일어나는 곳에 더 가깝게 가져와 중개자를 제거하는 것이었습니다. 프로젝트, 환경, 그리고 작업을 조율하는 CLI만 있으면 됩니다.

## l10n은 소프트웨어 산업에 대한 우리의 선물입니다

우리는 더 많은 소프트웨어가 로컬라이즈되기를 바라며 l10n을 만들었습니다.

복잡한 프로세스와 비싼 플랫폼은 작은 팀, 인디 개발자, 오픈소스 프로젝트에게 로컬라이제이션을 접근 불가능하게 만듭니다. 번역 워크플로우에 구매 프로세스, 단어당 가격 협상, 핸드오프를 조율할 프로젝트 매니저가 필요하다면, 대부분의 팀은 그냥 영어로 출시하고 끝낼 것입니다.

l10n은 오픈소스입니다. 이미 접근 가능한 모델을 사용합니다. 터미널에서 실행됩니다. 그리고 우리 도구가 아닌 여러분의 도구로 출력을 검증합니다.

우리는 로컬라이제이션이 테스트 스위트를 실행하는 것만큼 자연스러워야 한다고 생각합니다.

## 다음 단계: 휴먼 인풋 경험

오늘날 l10n은 개발자를 위해 설계된 CLI 도구입니다. 하지만 로컬라이제이션 품질에 기여하는 모든 사람이 개발자는 아니라는 것을 알고 있습니다.

OpenAI가 Codex용 데스크톱 앱으로 터미널을 추상화한 것처럼, 휴먼 인풋 경험이 어떤 모습일 수 있는지 탐구하고 싶습니다. 언어학자가 브랜치, 컴파일, JSON에 대해 생각할 필요 없는 경험. 콘텐츠, 컨텍스트, 번역을 나란히 보는 경험. 다듬어야 할 것을 다듬습니다. 그리고 도구가 나머지 모든 것을 처리합니다: 커밋, 검증, 풀 리퀘스트 열기.

터미널은 가장 어려운 문제들이 먼저 해결되는 곳이기에 올바른 시작점입니다. 하지만 결승선은 소프트웨어가 모든 언어를 말하게 만드는 데 관심 있는 모든 사람을 환영하는 경험입니다.

## 시작하기

[mise](https://mise.jdx.dev)로 CLI를 설치하세요:

```bash
mise use github:tuist/l10n
```

그런 다음 프로젝트를 초기화하세요:

```bash
l10n init
```

저장소 루트에 `L10N.md` 파일이 생성되며, 여기서 LLM 제공자, 소스 파일, 대상 언어를 설정합니다. 설정이 완료되면 다음 명령으로 콘텐츠를 번역하세요:

```bash
l10n translate
```

`l10n status`로 오래된 항목을 확인하고, `l10n check`로 출력을 검증하세요. 이게 전부입니다. 가입할 플랫폼도, 관리할 대시보드도, 협상할 벤더도 없습니다.

l10n은 완전히 무료이며 오픈소스입니다. 완성된 제품처럼 느껴진다면, 의도된 것입니다. [Tuist](https://tuist.dev)에서 우리는 오픈소스 작업도 제품처럼 다룹니다. 우리가 출시하는 모든 것에 쏟는 것과 같은 관심, 같은 개발자 경험에 대한 주의, 같은 품질 기준을 l10n에도 적용합니다. 오픈소스는 그 수준의 정성을 받을 자격이 있고, 이에 의존하는 팀들도 마찬가지라고 믿습니다.